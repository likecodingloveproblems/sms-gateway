یکی از مهم ترین اجزای سیستم مورد نظر message broker آن میباشد.
گزینه های پیشنهادی:
1. Redis streams
2. RabbitMQ
3. Kafka

سناریو هایی که میخواهیم با استفاده از message broker برای آنها به راه حلی ساده و قابل اعتماد برسیم.
۱. میخواهیم بتوانیم توزیع منابع به صورت عادلانه بین مشتریان را با استفاده از broker انجام دهیم. به این صورت که وقتی event مربوط به ارسال پیام مشتری به سیستم تحویل داده میشود broker بتواند پیام های consumer ها را به صورت عادلانه بین مشتری ها تقسیم کند.
۲. پاک سازی پیام پس از پردازش موفق پیام برای آزاد سازی منابع سیستم.

#### سوالات کلیدی
۱. به چه مقدار منابع نیاز داریم؟
### بررسی دقیق تر تکنولوژی های پیشنهادی
#### Redis streams
دیتابیس redis بسیار محبوب و پر کاربرد میباشد. از redis به عنوان in-memory دیتابیس برای cache بسیار محبوب است.
یکی از ویژگی های اصلی ردیس سادگی آن میباشد.
برای سناریوی اول میتوان برای هر مشتری stream جداگانه ای ساخت و در هر consumption loop به تعداد مشخصی از تمامی stream ها consume شود. لذا بین مشتری ها عدالت برقرار میشود.
میتوان با xtrim و xdel پیام هایی که خوانده شده را پاک کرد.
و در عین حال میتوان با استفاده از consumer group لود را بین consumer ها تقسیم کرد و از دوباره خوانده شدن یک پیام امتناع کرد. درعین حال با استفاده از pending list ‌میتوان لیست پیام هایی که پردازش نشده اند را به صورت دوره ای پردازش کرد در مواردی که یک consumer دچار مشکل شده است.

#### معایب
۱. ردیس دیتا ها را در مووری ذخیره ساززی میکند لذا نگهداری دیتا به صورت دراز مدت بسیار گران خواهد بود. از طرفی این منبع جزو منابع گران محسوب میشود. طبق محاسبات پیشنهادی توسط chatgpt برای ذخیره سازی پیام های یک روز به صورت متنی به 33G‌B رم نیاز است که البته میتوان این مقدار را با استفاده از  protobuf بهینه کرد.[link](https://chatgpt.com/share/6883bdf1-1d1c-800d-9e0f-011526edbecf)
۲. redis به ما تضمین نمیدهد که دیتا را به صورت durable نگه دارد و ممکن است دیتا در مواردی از دست برود که البته با تکنیک هایی مانند replication میتوان احتمال این مساله را کم کرد.

#### مزایا
۱. سادگی
۲. latency and throughput ردیس بسیار latency پایین و نرخ writeبالایی را به ما خواهد داد و به راحتی تا 100,000 XADD per second را پشتیبانی میکند.
۳. قابلیت های بسیار خوب: streams به خوبی این قابلیت را به کاربر میدهد تا پیام های مختلف را صرفا یکبار پردازش کند و در صورت بروز مشکل مکانیزمی برای retry در صورت وجود مشکل در پردازش داشته باشد.

#### Kafka
تکنولوژی kafka به صورت گسترده برای ذخیره سازی log‌ ها در scale بسیار زیاد در شرکت های مطرح مورد استفاده قرار گرفته است و تضمین durability  بعد از ذخیره سازی را میدهد.
با استفاده از consumer group های کافکا میتوان consumer‌ها را در یک گروه مدیریت کرد به این صورت که worker tasks رو پیاده سازی کرد.
اما برای مساله اول به نظر میاد راه حل در کافکا به این صورت خواهد بود که بر روی یک topic به تعداد customer ها partition‌ساخته میشود و در زمان ساخت message به صورت دستی به partition مورد نظر اساین میشود و consumer group خود مسیولیت load balancing رو برعهده میگیرد لیکن مشکلی که وجود خواهد داشت این خواهد بود که kafka نمیتواند پس از اساین consumer ها به partition ها در صورتی که consumer ای تمامی partition‌هایش خالی میباشد rebalance انجام دهد.
یکی از مزیت های kafka اکوسیستم غنی kafka connect میباشد که با آن میتوان کافکا را به ابزار های دیگر بدون زحمت متصل کرد. برای مثال برای قسمت reporting میتوان از kafka connect برای ذخیره سازی پر دیتابیس مورد نظر استفاده کرد.

###### معایب
پیچیدگی زیاد

###### مزایا
durability
scalability
connect
###### External Links
[chatgpt.chat](https://chatgpt.com/share/6884760b-49c4-800d-be35-869031906761)

#### RabbitMQ
این تکنولوژی نیز بسیار جا افتاده بوده و در بیزینس های بزرگ نیز به عنوان broker از آن استفاده میشود.
این تکنولوژی مانند apache Kafka تضمین durability‌را نمیدهد اما میتوان با کانفیگ مناسب به آن رسید.
پیچیدگی کمتر نسبت به Kafka و پشتیبانی routing پیچیده.

راه حل پیشنهادی برای مساله توزیع پیام ها میتوان به تعداد کاربران queue ایجاد کرده و در مرتب از تمام صف ها تعداد مشخصی پیام دریافت شود.

###### مزایا
از کافکا ساده تر بوده ولی از redis پیچیده تر میباشد.
قابلیت routing پیچیده که البته در مساله ما مورد استفاده نخواهد بود

###### معایب
پیچیدگی در cluster کردن
نداشتن اکوسیستم غنی kafka connect
به نظر میاد در مدیریت صفوف با تعداد خیلی زیاد 100,000 ممکن هست rabbit به مشکل بخورد.

###### External link
[chatgpt](https://chatgpt.com/share/68847ad1-0578-800d-875a-d6bf295a56ef)


## راه حل انتخابی

از آن جا که در مساله فعلی تلاش بر سادگی میباشد و نیز redis streams نیاز های مساله ما را بر طرف میکند redis stream پیشنهاد میشود.
برای scale‌ ای که مساله ما مطرح کرده redis به راحتی پشتیبانی خواهد کرد. (5,000 OPS)
از انجا که از redis برای cache نیز استفاده شده است استک کوچیک نگه داشته میشه.
سادگی در deploy و استفاده.
*از آن جهت که redis داده ما را در RAM نگه میدارد این مساله میتواند مشکل ساز باشد در صورتی که مانیتورینگ قوی روی آن پیاده نشده باشد.*
**تحمین حجم مورد نیاز**
برای ذخیره سازی ۱ روز پیام ها معادل ۱۰۰ میلیون پیام در یک stream بدون استفاده از protobuf به 33GB مموری نیاز است.
برای ذخیره سازی balance اکانت ها به چیزی در حدود 2MB نیاز هست. یعنی برای اینکه ی مقداری خیالمون راحت باشه که در صورت failure پیام ها پاک نمیشن و redis به مشکل نمیخوره میتونیم با 128 GB شروع کنیم. [link](https://chatgpt.com/share/6883bdf1-1d1c-800d-9e0f-011526edbecf)
